title: 如何选择机器学习分类器？
date: 2015-04-24 17:36:45
tags:
categories: 算法
---
<div>
<div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
<p style="max-width: 100%; word-wrap: normal; box-sizing: border-box !important; min-height: 1em; white-space: pre-wrap; color: rgb(62, 62, 62); font-family: 'Helvetica Neue', Helvetica, 'Hiragino Sans GB', 'Microsoft YaHei', 微软雅黑, Arial, sans-serif; font-size: 16px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: 25.6000003814697px; orphans: auto; text-align: start; text-transform: none; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-indent: 28px; background-color: rgb(255, 255, 255);"><span style="max-width: 100%; word-wrap: break-word !important; box-sizing: border-box !important; font-family: 宋体;">你知道如何为你的分类问题选择合适的机器学习算法吗？当然，如果你真正关心准确率，那么最佳方法是测试各种不同的算法（同时还要确保对每个算法测试不同参数），然后通过交叉验证选择最好的一个。但是，如果你只是为你的问题寻找一个“足够好”的算法，或者一个起点，这里有一些我这些年发现的还不错的一般准则。</span></p>
<p style="max-width: 100%; word-wrap: normal; box-sizing: border-box !important; min-height: 1em; white-space: pre-wrap; color: rgb(62, 62, 62); font-family: 'Helvetica Neue', Helvetica, 'Hiragino Sans GB', 'Microsoft YaHei', 微软雅黑, Arial, sans-serif; font-size: 16px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: 25.6000003814697px; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><strong style="max-width: 100%; word-wrap: break-word !important; box-sizing: border-box !important;"><span style="max-width: 100%; word-wrap: break-word !important; box-sizing: border-box !important; font-family: 宋体;">　　你的训练集有多大？</span></strong></p>
<p style="max-width: 100%; word-wrap: normal; box-sizing: border-box !important; min-height: 1em; white-space: pre-wrap; color: rgb(62, 62, 62); font-family: 'Helvetica Neue', Helvetica, 'Hiragino Sans GB', 'Microsoft YaHei', 微软雅黑, Arial, sans-serif; font-size: 16px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: 25.6000003814697px; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="max-width: 100%; word-wrap: break-word !important; box-sizing: border-box !important; font-family: 宋体;">　　如果训练集很小，那么高偏差</span>/<span style="max-width: 100%; word-wrap: break-word !important; box-sizing: border-box !important; font-family: 宋体;">低方差分类器（如朴素贝叶斯分类器）要优于低偏差</span>/<span style="max-width: 100%; word-wrap: break-word !important; box-sizing: border-box !important; font-family: 宋体;">高方差分类器（如</span>k<span style="max-width: 100%; word-wrap: break-word !important; box-sizing: border-box !important; font-family: 宋体;">近邻分类器），因为后者容易过拟合。然而，随着训练集的增大，低偏差</span>/<span style="max-width: 100%; word-wrap: break-word !important; box-sizing: border-box !important; font-family: 宋体;">高方差分类器将开始胜出（它们具有较低的渐近误差），因为高偏差分类器不足以提供准确的模型。</span></p>
<p style="max-width: 100%; word-wrap: normal; box-sizing: border-box !important; min-height: 1em; white-space: pre-wrap; color: rgb(62, 62, 62); font-family: 'Helvetica Neue', Helvetica, 'Hiragino Sans GB', 'Microsoft YaHei', 微软雅黑, Arial, sans-serif; font-size: 16px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: 25.6000003814697px; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="max-width: 100%; word-wrap: break-word !important; box-sizing: border-box !important; font-family: 宋体;">　　你也可以认为这是生成模型与判别模型的区别。</span></p>
<p style="max-width: 100%; word-wrap: normal; box-sizing: border-box !important; min-height: 1em; white-space: pre-wrap; color: rgb(62, 62, 62); font-family: 'Helvetica Neue', Helvetica, 'Hiragino Sans GB', 'Microsoft YaHei', 微软雅黑, Arial, sans-serif; font-size: 16px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: 25.6000003814697px; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="max-width: 100%; word-wrap: break-word !important; box-sizing: border-box !important; font-family: 宋体;">　<strong style="max-width: 100%; word-wrap: break-word !important; box-sizing: border-box !important;">　一些特定算法的优点</strong></span></p>
<p style="max-width: 100%; word-wrap: normal; box-sizing: border-box !important; min-height: 1em; white-space: pre-wrap; color: rgb(62, 62, 62); font-family: 'Helvetica Neue', Helvetica, 'Hiragino Sans GB', 'Microsoft YaHei', 微软雅黑, Arial, sans-serif; font-size: 16px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: 25.6000003814697px; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="max-width: 100%; word-wrap: break-word !important; box-sizing: border-box !important; font-family: 宋体;">　　<strong style="max-width: 100%; word-wrap: break-word !important; box-sizing: border-box !important;">朴素贝叶斯的优点：</strong>超级简单，你只是在做一串计算。如果朴素贝叶斯（</span>NB<span style="max-width: 100%; word-wrap: break-word !important; box-sizing: border-box !important; font-family: 宋体;">）条件独立性假设成立，相比于逻辑回归这类的判别模型，朴素贝叶斯分类器将收敛得更快，所以你只需要较小的训练集。而且，即使</span> NB <span style="max-width: 100%; word-wrap: break-word !important; box-sizing: border-box !important; font-family: 宋体;">假设不成立，朴素贝叶斯分类器在实践方面仍然表现很好。如果想得到简单快捷的执行效果，这将是个好的选择。它的主要缺点是，不能学习特征之间的相互作用（比如，它不能学习出：虽然你喜欢布拉德·皮特和汤姆·克鲁斯的电影，但却不喜欢他们一起合作的电影）。</span></p>
<p style="max-width: 100%; word-wrap: normal; box-sizing: border-box !important; min-height: 1em; white-space: pre-wrap; color: rgb(62, 62, 62); font-family: 'Helvetica Neue', Helvetica, 'Hiragino Sans GB', 'Microsoft YaHei', 微软雅黑, Arial, sans-serif; font-size: 16px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: 25.6000003814697px; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="max-width: 100%; word-wrap: break-word !important; box-sizing: border-box !important; font-family: 宋体;">　　<strong style="max-width: 100%; word-wrap: break-word !important; box-sizing: border-box !important;">逻辑回归的优点</strong>：有许多正则化模型的方法，你不需要像在朴素贝叶斯分类器中那样担心特征间的相互关联性。与决策树和支撑向量机不同，你还可以有一个很好的概率解释，并能容易地更新模型来吸收新数据（使用一个在线梯度下降方法）。如果你想要一个概率框架（比如，简单地调整分类阈值，说出什么时候是不太确定的，或者获得置信区间），或你期望未来接收更多想要快速并入模型中的训练数据，就选择逻辑回归。</span></p>
<p style="max-width: 100%; word-wrap: normal; box-sizing: border-box !important; min-height: 1em; white-space: pre-wrap; color: rgb(62, 62, 62); font-family: 'Helvetica Neue', Helvetica, 'Hiragino Sans GB', 'Microsoft YaHei', 微软雅黑, Arial, sans-serif; font-size: 16px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: 25.6000003814697px; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="max-width: 100%; word-wrap: break-word !important; box-sizing: border-box !important; font-family: 宋体;">　　<strong style="max-width: 100%; word-wrap: break-word !important; box-sizing: border-box !important;">决策树的优点：</strong>易于说明和解释（对某些人来说—我不确定自己是否属于这个阵营）。它们可以很容易地处理特征间的相互作用，并且是非参数化的，所以你不用担心异常值或者数据是否线性可分（比如，决策树可以很容易地某特征</span>x<span style="max-width: 100%; word-wrap: break-word !important; box-sizing: border-box !important; font-family: 宋体;">的低端是类</span>A<span style="max-width: 100%; word-wrap: break-word !important; box-sizing: border-box !important; font-family: 宋体;">，中间是类</span>B<span style="max-width: 100%; word-wrap: break-word !important; box-sizing: border-box !important; font-family: 宋体;">，然后高端又是类</span>A<span style="max-width: 100%; word-wrap: break-word !important; box-sizing: border-box !important; font-family: 宋体;">的情况）。一个缺点是，不支持在线学习，所以当有新样本时，你将不得不重建决策树。另一个缺点是，容易过拟合，但这也正是诸如随机森林（或提高树）之类的集成方法的切入点。另外，随机森林往往是很多分类问题的赢家（我相信通常略优于支持向量机），它们快速并且可扩展，同时你不须担心要像支持向量机那样调一堆参数，所以它们最近似乎相当受欢迎。</span></p>
<p style="max-width: 100%; word-wrap: normal; box-sizing: border-box !important; min-height: 1em; white-space: pre-wrap; color: rgb(62, 62, 62); font-family: 'Helvetica Neue', Helvetica, 'Hiragino Sans GB', 'Microsoft YaHei', 微软雅黑, Arial, sans-serif; font-size: 16px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: 25.6000003814697px; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><strong style="max-width: 100%; word-wrap: break-word !important; box-sizing: border-box !important;">SVMs <span style="max-width: 100%; word-wrap: break-word !important; box-sizing: border-box !important; font-family: 宋体;">的优点：</span></strong><span style="max-width: 100%; word-wrap: break-word !important; box-sizing: border-box !important; font-family: 宋体;">高准确率，为过拟合提供了好的理论保证，并且即使你的数据在基础特征空间线性不可分，只要选定一个恰当的核函数，它们仍然能够取得很好的分类效果。它们在超高维空间是常态的文本分类问题中尤其受欢迎。然而，它们内存消耗大，难于解释，运行和调参也有些烦人，因此，我认为随机森林正渐渐开始偷走它的“王冠”。</span></p>
<p style="max-width: 100%; word-wrap: normal; box-sizing: border-box !important; min-height: 1em; white-space: pre-wrap; color: rgb(62, 62, 62); font-family: 'Helvetica Neue', Helvetica, 'Hiragino Sans GB', 'Microsoft YaHei', 微软雅黑, Arial, sans-serif; font-size: 16px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: 25.6000003814697px; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="max-width: 100%; word-wrap: break-word !important; box-sizing: border-box !important; font-family: 宋体;">　<strong style="max-width: 100%; word-wrap: break-word !important; box-sizing: border-box !important;">　然而…</strong></span></p>
<p style="max-width: 100%; word-wrap: normal; box-sizing: border-box !important; min-height: 1em; white-space: pre-wrap; color: rgb(62, 62, 62); font-family: 'Helvetica Neue', Helvetica, 'Hiragino Sans GB', 'Microsoft YaHei', 微软雅黑, Arial, sans-serif; font-size: 16px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: 25.6000003814697px; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="max-width: 100%; word-wrap: break-word !important; box-sizing: border-box !important; font-family: 宋体;">　　尽管如此，回忆一下，更好的数据往往打败更好的算法，设计好的特征大有裨益。并且，如果你有一个庞大数据集，这时你使用哪种分类算法在分类性能方面可能并不要紧（所以，要基于速度和易用性选择算法）。</span></p>
<p style="max-width: 100%; word-wrap: normal; box-sizing: border-box !important; min-height: 1em; white-space: pre-wrap; color: rgb(62, 62, 62); font-family: 'Helvetica Neue', Helvetica, 'Hiragino Sans GB', 'Microsoft YaHei', 微软雅黑, Arial, sans-serif; font-size: 16px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: 25.6000003814697px; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="max-width: 100%; word-wrap: break-word !important; box-sizing: border-box !important; font-family: 宋体;">　　重申我上面说的，如果你真的关心准确率，一定要尝试各种各样的分类器，并通过交叉验证选择最好的一个。或者，从</span> Netflix Prize (<span style="max-width: 100%; word-wrap: break-word !important; box-sizing: border-box !important; font-family: 宋体;">和</span> Middle Earth)<span style="max-width: 100%; word-wrap: break-word !important; box-sizing: border-box !important; font-family: 宋体;">中吸取教训，只使用了一个集成方法进行选择。</span></p>
</div>
</div>